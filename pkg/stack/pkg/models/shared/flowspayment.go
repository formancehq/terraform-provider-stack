// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/formancehq/formance-sdk-go/v3/pkg/utils"
	"math/big"
	"time"
)

type FlowsPaymentRaw struct {
}

type FlowsPaymentScheme string

const (
	FlowsPaymentSchemeVisa       FlowsPaymentScheme = "visa"
	FlowsPaymentSchemeMastercard FlowsPaymentScheme = "mastercard"
	FlowsPaymentSchemeAmex       FlowsPaymentScheme = "amex"
	FlowsPaymentSchemeDiners     FlowsPaymentScheme = "diners"
	FlowsPaymentSchemeDiscover   FlowsPaymentScheme = "discover"
	FlowsPaymentSchemeJcb        FlowsPaymentScheme = "jcb"
	FlowsPaymentSchemeUnionpay   FlowsPaymentScheme = "unionpay"
	FlowsPaymentSchemeSepaDebit  FlowsPaymentScheme = "sepa debit"
	FlowsPaymentSchemeSepaCredit FlowsPaymentScheme = "sepa credit"
	FlowsPaymentSchemeSepa       FlowsPaymentScheme = "sepa"
	FlowsPaymentSchemeApplePay   FlowsPaymentScheme = "apple pay"
	FlowsPaymentSchemeGooglePay  FlowsPaymentScheme = "google pay"
	FlowsPaymentSchemeA2a        FlowsPaymentScheme = "a2a"
	FlowsPaymentSchemeAchDebit   FlowsPaymentScheme = "ach debit"
	FlowsPaymentSchemeAch        FlowsPaymentScheme = "ach"
	FlowsPaymentSchemeRtp        FlowsPaymentScheme = "rtp"
	FlowsPaymentSchemeUnknown    FlowsPaymentScheme = "unknown"
	FlowsPaymentSchemeOther      FlowsPaymentScheme = "other"
)

func (e FlowsPaymentScheme) ToPointer() *FlowsPaymentScheme {
	return &e
}
func (e *FlowsPaymentScheme) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "visa":
		fallthrough
	case "mastercard":
		fallthrough
	case "amex":
		fallthrough
	case "diners":
		fallthrough
	case "discover":
		fallthrough
	case "jcb":
		fallthrough
	case "unionpay":
		fallthrough
	case "sepa debit":
		fallthrough
	case "sepa credit":
		fallthrough
	case "sepa":
		fallthrough
	case "apple pay":
		fallthrough
	case "google pay":
		fallthrough
	case "a2a":
		fallthrough
	case "ach debit":
		fallthrough
	case "ach":
		fallthrough
	case "rtp":
		fallthrough
	case "unknown":
		fallthrough
	case "other":
		*e = FlowsPaymentScheme(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlowsPaymentScheme: %v", v)
	}
}

type FlowsPaymentType string

const (
	FlowsPaymentTypePayIn    FlowsPaymentType = "PAY-IN"
	FlowsPaymentTypePayout   FlowsPaymentType = "PAYOUT"
	FlowsPaymentTypeTransfer FlowsPaymentType = "TRANSFER"
	FlowsPaymentTypeOther    FlowsPaymentType = "OTHER"
)

func (e FlowsPaymentType) ToPointer() *FlowsPaymentType {
	return &e
}
func (e *FlowsPaymentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PAY-IN":
		fallthrough
	case "PAYOUT":
		fallthrough
	case "TRANSFER":
		fallthrough
	case "OTHER":
		*e = FlowsPaymentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlowsPaymentType: %v", v)
	}
}

type FlowsPayment struct {
	Adjustments          []FlowsPaymentAdjustment `json:"adjustments"`
	Asset                string                   `json:"asset"`
	ConnectorID          string                   `json:"connectorID"`
	CreatedAt            time.Time                `json:"createdAt"`
	DestinationAccountID string                   `json:"destinationAccountID"`
	ID                   string                   `json:"id"`
	InitialAmount        *big.Int                 `json:"initialAmount"`
	Metadata             *FlowsPaymentMetadata    `json:"metadata"`
	Provider             *FlowsConnector          `json:"provider,omitempty"`
	Raw                  *FlowsPaymentRaw         `json:"raw"`
	Reference            string                   `json:"reference"`
	Scheme               FlowsPaymentScheme       `json:"scheme"`
	SourceAccountID      string                   `json:"sourceAccountID"`
	Status               FlowsPaymentStatus       `json:"status"`
	Type                 FlowsPaymentType         `json:"type"`
}

func (f FlowsPayment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlowsPayment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"adjustments", "asset", "connectorID", "createdAt", "destinationAccountID", "id", "initialAmount", "reference", "scheme", "sourceAccountID", "status", "type"}); err != nil {
		return err
	}
	return nil
}

func (f *FlowsPayment) GetAdjustments() []FlowsPaymentAdjustment {
	if f == nil {
		return []FlowsPaymentAdjustment{}
	}
	return f.Adjustments
}

func (f *FlowsPayment) GetAsset() string {
	if f == nil {
		return ""
	}
	return f.Asset
}

func (f *FlowsPayment) GetConnectorID() string {
	if f == nil {
		return ""
	}
	return f.ConnectorID
}

func (f *FlowsPayment) GetCreatedAt() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.CreatedAt
}

func (f *FlowsPayment) GetDestinationAccountID() string {
	if f == nil {
		return ""
	}
	return f.DestinationAccountID
}

func (f *FlowsPayment) GetID() string {
	if f == nil {
		return ""
	}
	return f.ID
}

func (f *FlowsPayment) GetInitialAmount() *big.Int {
	if f == nil {
		return big.NewInt(0)
	}
	return f.InitialAmount
}

func (f *FlowsPayment) GetMetadata() *FlowsPaymentMetadata {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *FlowsPayment) GetProvider() *FlowsConnector {
	if f == nil {
		return nil
	}
	return f.Provider
}

func (f *FlowsPayment) GetRaw() *FlowsPaymentRaw {
	if f == nil {
		return nil
	}
	return f.Raw
}

func (f *FlowsPayment) GetReference() string {
	if f == nil {
		return ""
	}
	return f.Reference
}

func (f *FlowsPayment) GetScheme() FlowsPaymentScheme {
	if f == nil {
		return FlowsPaymentScheme("")
	}
	return f.Scheme
}

func (f *FlowsPayment) GetSourceAccountID() string {
	if f == nil {
		return ""
	}
	return f.SourceAccountID
}

func (f *FlowsPayment) GetStatus() FlowsPaymentStatus {
	if f == nil {
		return FlowsPaymentStatus("")
	}
	return f.Status
}

func (f *FlowsPayment) GetType() FlowsPaymentType {
	if f == nil {
		return FlowsPaymentType("")
	}
	return f.Type
}
